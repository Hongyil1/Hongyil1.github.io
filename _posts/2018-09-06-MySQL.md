---
layout:     post
title:      MySQL Review
subtitle:   Knowledge and command in MySql
date:       2018-09-06
author:     Hongyi
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - MySQL
---

# Relational Database vs Non-relational Database
**SQL database** uses structured query language (SQL) for defining and manipulating data. SQL requires that you use predefined schemas to determine the structure of your data before you work with it. All of your data must follow the same structure. Its advantages are that itis safer and great for complex queries. The downsides are that it lacks of the flexibiltiy and the data structure is fixed.

**NoSQL database** has dynamic schema for unstructured data, and data is stored in many ways. The data is stored in many ways: column-oriented, document-oriented, graph-based or organized as KeyValue store. The flexibility means that: 1. You don't need to define the data structure before you create the doucments. 2. The structure of documents can be different.

### MySQL vs MongoDB
The following are some **MySQL** benefits and strengths:
- Open source, it's free.
- MYSQL is available for all major platforms: Linux, Windows, Mac etc. 
- MYSQL can be connected to many programing languages like Python, PHP, Java, Node.js and so on.
- The MYSQL database can be replicated across multiple nodes. It can balance the workload.

The following are some **MongoDB** benefits and strengths:
- Open source, it's free.
- It's flexible to change the data structure.
- Its horizontal scalability is able to reduece the workload.
- It's high-performing for simple queries.

# Basic MySQL Command
## MYSQL start
### MySQL Connection
```
sudo service mysql start
mysql -u root
```
### Create MySQL database
```
create database database_name;
```
### Delete database
```
drop database database_name;
```
### Choose database
```
show databases;
use database_name;
```
### Data Type
There are three main types in MySQL database: **Numeric** types, the **DATATIME, DATE and TIMESTAMP** types and **String** Types. 
#### Numeric

| Types         | Length in Bytes| Range                    |
| :-----------: |:--------------:| :-----------------------:|
| TINYINT       | 1              | (-128，127)              |
| SMALLINT      | 2              | (-32 768，32 767)        |
| MEDIUMINT     | 3              | (-8 388 608，8 388 607)  |
| INT/INTEGER   | 4              | (-2 147 483 648，2 147 483 647) |
| BIGINT        | 8              | (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) |
| FLOAT         | 4              | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) |
| DOUBLE        | 8              | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |
| DECIMAL       | DECIMAL(M,D):if M>D: M+2, else: D+2       | Depends on M, D |

#### DATATIME, DATE and TIMESTAMP

| Types         | Length in Bytes| Range                    | Format    |
| :-----------: |:--------------:| :-----------------------:| :--------:|
| DATE          | 3              | 1000-01-01/9999-12-31              | YYYY-MM-DD   |
| TIME          | 3              | '-838:59:59'/'838:59:59'        | HH:MM:SS   |
| YEAR          | 1              | 1901/2155              | YYYY   |
| DATETIME      | 8              | 1000-01-01 00:00:00/9999-12-31 23:59:59        | YYYY-MM-DD HH:MM:SS   |
| TIMESTAMP     | 4              | 1970-01-01 00:00:00/2038        | YYYYMMDD HHMMSS   |

#### String

| Types         | Range          |
| :-----------: |:--------------:|
| CHAR          | 0-255 (constant length)              | 
| VARCHAR          | 0-65535 (changeable length)             | 
| TINYBLOB         | 0-255 (binary string)              | 
| TINYTEXT      | 0-255              | 
| BLOB     | 0-65 535              |
| TEXT          | 0-65 535             | 
| MEDIUMBLOB          | 0-16 777 215              | 
| MEDIUMTEXT         | 0-16 777 215              | 
| LONGBLOB      | 0-4 294 967 295              | 
| LONGTEXT     | 0-4 294 967 295              |

### Create Table 
```
create table table_name (column_name column_type);
```
```
create table if not exists runoob_tbl(
    runoob_id INT UNSIGNED AUTO_INCREMENT,
    runoob_title VARCHAR(100) NOT NULL,
    runoob_author VARCHAR(40) NOT NULL,
    submission_date DATE,
    PRIMARY KEY (runoob_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
**NOT NULL** enforces the input to be not null. **AUTO_INCREMENT** is mainly used in Primary key.

### Delete table
```
DROP TABLE table_name;
```
### Insert data
```
INSERT INTO table_name (field1, field2, ...fieldN)
                        VALUES
                        (value1, value2,...valueN);
```
## MYSQL Query
The Sample Database comes from [MySQL Tutorial](http://www.mysqltutorial.org/mysql-sample-database.aspx).
MySQL Sample Database Schema shows below:
* **Customers**: stores customer's data
* **Products**: stores a list of scale model cars.
* **ProductLines**: stores a list of product line categories.
* **Orders:**: stores sales orders placed by customers.
* **OrderDetails**: stores sales order line items for each sales order.
* **Payments**: stores payments made by customers based on their account.
* **Employees**: stores all employee information as well as the organization structure such as who reports to whom.
* **Offices**: stores sales office data.

<p align="center">
<img width="600" alt="mysql-sample" src="https://user-images.githubusercontent.com/22671087/45188811-5c0ddf00-b279-11e8-93c7-290862425507.PNG"></p>

### Select
```
SELECT [DISTINCT]
    column_1, column_2, ...
FROM
    table_1
[INNER | LEFT | RIGHT] JOIN table_2 ON conditions
WHERE
    conditions
GROUP BY column_1
HAVING group_conditions
ORDER BY column_1
LIMIT offset, length;
```
* **DISTINCT** is used to eliminate duplicate rows in a result set.
* **FROM** specifies the table or view where you want to query the data.
* **JOIN** gets related data from other tables based on specific join conditions.
* **WHERE** clause filters row in the result set.
* **GROUP BY** groups a set of rows into groups and applies aggregate functions on each group.
* **HAVING** filters group based on groups defined by GROUP BY clause.
* **ORDER BY** specifies a list of columns for sorting.
* **LIMIT** constrains the number of returned rows.

### Where
```
SELECT
    select_list
FROM
    table_name
WHERE
    search_condition_1 AND/OR
    search_condition_2;
```
The *search_condition* is a combination of one or more predicates using the logical operator **AND, OR and NOT**. In SQL, a predicate is an expression that evaluates to true, false, or unknown.

| Operator  | Description              |
|:----------|:-------------------------|
| =         | Equal to.                |
| <> or !=  | Not equal to.            |
| <         | Less than                |
| >         | Greater than             |
| <=        | Less than or equal to    | 
| >=        | Greater than or equal to |

### AND
The *AND* operator is a logical operator that combines two or more **Boolean** expressions and returns true only if both expressions evaluate to true.
```
WHERE boolean_expression_1 AND boolean_expression_2
```
|          | **TRUE**  | **FALSE** | **NULL**  |
|:--------:|:---------:|:---------:|:---------:|
| **TRUE** | TRUE      | FALSE     | NULL      |
| **FALSE**| FALSE     | FALSE     | FALSE     |
| **NULL** | NULL      | FALSE     | NULL      |

The *AND* operator is often used in the **WHERE** clause of the **SELECT, UPDATE, DELETE** statement to form Boolean expressions. The *AND* operator is also used in join conditions of the **INNER JOIN** and **LEFT JOIN** clauses.

When evaluating an expression that has the *AND* operator, MySQL evaluates the remaining parts of the expression until it can determoine the result. This function is called short-circuit evaluation.

```
SELECT 1 = 0 AND 1 / 0;
-------------------------
0
```
MySQL only evaluates the first part *1 = 0* of the expression *1 = 0 AND 1 / 0*. Because the expression *1 = 0* return false, MySQL can conclude the result of the whole expression, which is false. MySQL then does not evaluate the remaining part of the expression.

### OR
MySQL *OR* operator combines two Boolean expressions and returns true when either condition is true.

```
boolean_expression_1 OR boolean_expression_2
```
|          | **TRUE**  | **FALSE** | **NULL**  |
|:--------:|:---------:|:---------:|:---------:|
| **TRUE** | TRUE      | TRUE      | TRUE      |
| **FALSE**| TRUE      | FALSE     | NULL      |
| **NULL** | TRUE      | NULL      | NULL      |

```
SELECT 1 = 1 OR 1 / 0;
-----------------------------
1
```
The MySQL also uses short-circuit evaluation for the *OR* operator. The result is 1 because the expression 1 = 1 return true, MySQL does not evaluate the 1 / 0.

** Operator precedence **
MySQL evaluates the *OR* operators **after** the *AND* operators.

```
SELECT true OR false AND false;
-------------------------------
1
```
How it works:
1. First, MySQL evaluates false AND false, return false.
2. Second, MySQL evaluate true OR false, return true.

To change the order of evaluation, you use **parentheses**.
```
SELECT (true OR false) AND false;
----------------------------------
0
```



